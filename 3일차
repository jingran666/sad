### 1. **JSON 직렬화와 `undefined` 처리**

- `JSON.stringify()` 메서드는 객체 내에서 `undefined` 속성을 어떻게 처리할까요?
---JSON.stringify()는 undefined 값을 특정 방식으로 처리하며, 이를 통해 JSON 형식의 일관성을 유지합니다.
### 2. **배열 내의 `undefined` 값 처리**
- 배열의 요소 중 `undefined` 값이 포함된 경우, `JSON.stringify()`는 이를 어떻게 처리할까요?
---배열의 요소 중 undefined 값이 포함된 경우, JSON.stringify()는 해당 undefined 값을 null로 변환하여 결과 JSON 문자열에 포함합니다.

### 3. **`Date` 객체의 직렬화 결과**

- `JSON.stringify()`로 직렬화할 때 `Date` 객체는 어떤 형식으로 변환됩니까?
JSON.stringify()로 직렬화할 때, Date 객체는 ISO 8601 형식의 문자열로 변환됩니다

### 4. **`Date` 객체의 복원**

- `JSON.parse(JSON.stringify(new Date()))`의 실행 결과는 무엇입니까?

---JSON.parse(JSON.stringify(new Date()))의 실행 결과는 Date 객체가 아닌, 단순한 문자열로 변환된 날짜를 얻습니다

### 5. **JSON에서 지원하지 않는 데이터 타입**

- JSON 표준(ECMA-404)에서 지원하지 않는 데이터 타입을 두 가지 이상 나열하세요.

---함수(Function): JSON은 함수를 직렬화할 수 없으며, 함수는 JSON 형식에서 표현할 수 없습니다.
정규 표현식(Regular Expression): 정규 표현식도 JSON에서 지원되지 않으며, 직렬화할 수 없습니다.

### 6. **얕은 복사와 깊은 복사의 차이점**

- 얕은 복사와 깊은 복사의 차이를 간단하게 설명하세요.

---얕은 복사는 첫 번째 레벨만 복사하고 참조를 공유.
깊은 복사는 모든 레벨을 새롭게 복사하여 원본과 독립적.

### 7. **`JSON.parse(JSON.stringify())`와 깊은 복사**

- `JSON.parse(JSON.stringify())` 방식이 깊은 복사를 수행하지 못하는 경우를 설명하세요.

---JSON.parse(JSON.stringify()) 방식은 여러 데이터 타입에서 정보를 잃어버리므로, 완전한 깊은 복사를 수행하지 못합니다.

### 8. **얕은 복사 방법**

- 얕은 복사를 수행할 수 있는 자바스크립트의 방법을 3가지 이상 나열하세요.

---Object.assign() 메서드는 하나 이상의 출처 객체의 모든 열거 가능한 속성을 대상 객체에 복사합니다. 새로운 객체를 생성하지 않고, 지정한 대상 객체를 수정합니다.
전개 연산자(...)를 사용하면 객체를 쉽게 복사할 수 있습니다.
배열의 경우 slice() 메서드를 사용하여 얕은 복사를 수행할 수 있습니다. 빈 인수를 전달하면 전체 배열을 복사합니다.

### 9. **깊은 복사의 필요성**

- 깊은 복사가 필요한 상황을 예시로 설명하세요.

---복잡한 데이터 구조를 다룰 때, 얕은 복사로는 충분하지 않습니다. 예를 들어, 트리 구조의 데이터에서 특정 노드를 수정하고자 할 때 깊은 복사가 필요합니다.

### 10. **깊은 복사 구현 방법**

- `JSON.parse(JSON.stringify())` 외에 깊은 복사를 수행할 수 있는 방법을 제시하세요.

---재귀적으로 객체를 순회하면서 각 속성을 복사하는 함수를 작성할 수 있습니다. 이 방법은 객체의 깊이와 형태에 맞게 조정할 수 있습니다.

### 11. **`Object.assign()`의 한계**

- `Object.assign()` 메서드를 사용한 얕은 복사의 한계를 설명하세요.

---Object.assign()은 객체의 직접적인 속성만 복사하므로, 함수나 프로토타입 속성은 복사되지 않습니다. 객체의 메서드를 복사할 수 없습니다.

### 12. **배열 복사 시의 spread 연산자**

- 다음 코드에서 `originalArray`와 `copiedArray`는 서로 독립적인 배열일까요?
    
    ```jsx
    const originalArray = [1, 2, { a: 3 }];
    const copiedArray = [...originalArray];
    
    copiedArray[2].a = 4;
    ```
    

---

### 13. **재귀를 통한 깊은 복사**

- 깊은 복사를 수행하기 위한 재귀 복사 함수의 기본적인 원리를 설명하세요.

---기본형 데이터 처리, 객체 및 배열 확인, 새로운 객체/배열 생성, 속성 순회, 재귀 호출, 최종 결과 반환

### 14. **`JSON.stringify()`의 함수 처리**

- 객체 내에 함수가 포함된 경우 `JSON.stringify()`로 직렬화하면 어떻게 처리할까요?

---JSON.stringify()로 객체를 직렬화할 때, 객체 내에 포함된 함수는 직렬화 과정에서 무시됩니다.

### 15. **깊은 복사 후 객체 수정**

- 다음 코드에서 깊은 복사가 완료된 후, `copy.b.c` 값을 수정해도 `original.b.c` 값이 변경되지 않도록 하려면 어떻게 해야 할까요?
    
    ```jsx
    const original = { a: 1, b: { c: 2 } };
    const copy = Object.assign({}, original);
    
    copy.b.c = 3;
    ```
    

---

### 16. **`slice()`와 얕은 복사**

- 배열에서 `slice()` 메서드로 얕은 복사를 수행할 때, 중첩 배열이 있는 경우 그 동작을 설명하세요.

---slice() 메서드는 배열의 1레벨 요소만 복사하며, 중첩 배열은 참조로 유지됩니다.
중첩 배열의 요소를 수정하면 원본 배열에도 영향을 미칩니다. 따라서 중첩된 구조를 포함하는 경우에는 깊은 복사를 수행해야 할 필요가 있습니다.

### 17. **`JSON.parse()`의 반환 값**

- `JSON.parse('{"a":1, "b":true, "c":"hello"}')`는 어떤 값을 반환할까요?

---a: 숫자 1
b: 불리언 값 true
c: 문자열 "hello"

### 18. **깊은 복사 후 참조 확인**

- 깊은 복사된 배열과 원본 배열이 참조적으로 독립적인지 확인하려면 어떻게 해야 할까요?

---깊은 복사된 배열과 원본 배열이 참조적으로 독립적인지 확인하려면, 중첩된 요소의 변경 사항이 원본 배열에 영향을 미치는지 체크해야 합니다

### 19. **`Symbol` 타입의 직렬화**

- `Symbol` 타입이 객체 속성으로 포함된 경우, `JSON.stringify()`는 어떻게 처리할까요?

---Symbol 타입이 객체 속성으로 포함된 경우, JSON.stringify()는 해당 속성을 직렬화할 수 없습니다. Symbol 속성은 JSON 문자열에 포함되지 않으며, 결과적으로 무시됩니다.

### 20. **`JSON.stringify()`의 순환 참조 문제**

- 객체가 순환 참조(자기 자신을 참조)하는 경우 `JSON.stringify()`는 어떻게 동작할까요?
객체가 순환 참조(자기 자신을 참조)하는 경우, JSON.stringify()는 TypeError를 발생시킵니다. 순환 참조는 객체가 자신을 직접적으로 또는 간접적으로 참조할 때 발생하며, 이러한 구조는 JSON으로 표현할 수 없습니다.
